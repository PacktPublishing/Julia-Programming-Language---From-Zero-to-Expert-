WEBVTT

00:00.830 --> 00:04.470
In the previous video, we took a look at some basics of functions in Julia.

00:04.850 --> 00:08.470
In this video, we are going to take a look at three very important concepts.

00:08.810 --> 00:13.320
Two of these are not very often used, but they're still very important for you to understand.

00:13.520 --> 00:19.590
The third one is critical to Julia and the way machine learning and data science is structured in Julia.

00:19.730 --> 00:24.380
So this is going to be a very important video and hopefully it's going to be fairly straightforward.

00:24.380 --> 00:26.300
It's not complicated, but it's very useful.

00:26.630 --> 00:32.480
OK, so the concept is functional programming and the idea is that you have functions which act on data

00:32.750 --> 00:35.950
and while they're acting on it, they are not affected by the environment.

00:36.260 --> 00:41.270
So you can imagine that you have, let's say, one gigabytes of data which can be divided into five

00:41.270 --> 00:43.400
thousand or a million different parts.

00:43.700 --> 00:49.940
And each invocation of the function on each function call is going to work on one part only, and it's

00:49.940 --> 00:52.830
not going to be affected by how the function works on other parts.

00:53.240 --> 00:58.940
So this can massively parallel your code, and that is why functional programming has been gaining traction

00:59.390 --> 01:00.320
in the recent past.

01:00.350 --> 01:02.210
So Julia takes that a step further.

01:02.420 --> 01:04.710
And in this video, we're going to see how this works.

01:04.780 --> 01:06.630
OK, this is completely transparent.

01:06.650 --> 01:12.120
We just have to look at how Julia does things and it's going to do all the paralyzation for us automatically.

01:12.650 --> 01:14.890
This is going to be very useful when you get to machine learning.

01:14.900 --> 01:17.480
But here we are just taking a look at the basic syntax.

01:17.750 --> 01:19.790
So the three things are number one map.

01:20.090 --> 01:21.380
So MAP is fairly straightforward.

01:21.380 --> 01:26.150
If you haven't seen this before, let's say you have a list and you want to apply a function which is

01:26.150 --> 01:29.690
the square function to each element individually.

01:30.090 --> 01:37.130
So all you have to do is call map, give it a function that you want to apply to each element and give

01:37.130 --> 01:41.210
it a collection of all the elements that you want to apply the function on.

01:41.600 --> 01:47.150
So what that does is it goes ahead and applies this function on each individual element and collects

01:47.150 --> 01:48.670
the results in another area.

01:49.340 --> 01:52.100
So it's essentially mapping one collection to another collection.

01:52.580 --> 01:59.870
Obviously you can save this into a variable so squares and then you can go ahead and show this so that

01:59.870 --> 02:01.100
you can do one for 16.

02:01.370 --> 02:03.920
So a map, therefore, is a higher order function.

02:04.100 --> 02:09.650
A higher the function is a function that takes in another function as its argument.

02:09.800 --> 02:10.070
Right.

02:10.120 --> 02:12.500
So this function is being passed to map.

02:12.980 --> 02:15.230
So map itself is a higher order function.

02:15.500 --> 02:16.910
So there are other examples.

02:16.910 --> 02:18.860
We've seen an example of this before.

02:18.860 --> 02:20.600
So that was filtered in the previous video.

02:21.020 --> 02:26.600
These three mass-producing filter combined make like 90 percent of all functional programming.

02:26.600 --> 02:26.730
Right.

02:26.790 --> 02:33.110
So this is very important and that's all there is to map applies the same function on each individual

02:33.110 --> 02:34.060
element of a collection.

02:34.070 --> 02:34.460
That's it.

02:35.120 --> 02:38.170
Reduce does something similar with a minor change.

02:38.180 --> 02:43.370
So let's say you have the same collection, one to four again and you reduce it with the plus.

02:43.580 --> 02:47.780
So what that does is, as the name implies, it's going to take the first two elements and it's going

02:47.780 --> 02:49.190
to apply this function on them.

02:49.430 --> 02:54.690
Whatever result is produced, it's going to take that and four and apply the same function again.

02:54.710 --> 02:59.690
So essentially it takes the whole collection and reduces it to a final result.

03:00.170 --> 03:02.460
So much easier to demonstrate this.

03:02.480 --> 03:04.150
So let's just go ahead and show this.

03:04.400 --> 03:09.710
So what plus does is one plus two that becomes three, then three plus four that becomes seven.

03:10.520 --> 03:14.750
So if you have, let's say, 10 over here, this is going to be one plus two is going to be three three

03:14.840 --> 03:18.850
plus all is going to be seven and seven plus ten is going to be 17.

03:18.860 --> 03:20.580
So that is the result that we get out of it.

03:20.870 --> 03:27.980
So this seemed like very basic concepts, but they have been shown to essentially be able to do a wide

03:27.980 --> 03:30.490
variety of things that we want to do with machine learning and data.

03:30.690 --> 03:31.910
So you might have heard of Hadoop.

03:32.450 --> 03:35.270
That is a massively parallel processing architecture.

03:35.270 --> 03:40.850
And the architecture on top of which Hadoop stands is the mass-produced architecture or the mass produced

03:40.850 --> 03:41.240
framework.

03:41.240 --> 03:42.770
And this is where that name comes from.

03:43.010 --> 03:47.750
So just these two things, combined with Filter and a couple of other parts of functional programming

03:47.930 --> 03:50.150
are extremely popular, extremely powerful.

03:50.510 --> 03:55.220
In this course, we are going to be concerned with them just for simple case studies.

03:55.400 --> 03:58.750
We're not going to change our whole frameworks towards mass produce.

03:58.910 --> 04:01.600
So this is on Unit one designed for discourse.

04:02.630 --> 04:06.860
The third thing that is very essential for discourse and we are going to come back to this again and

04:06.860 --> 04:08.830
again is the concept of broadcasting.

04:09.200 --> 04:11.450
So again, the concept of broadcast is fairly simple.

04:11.780 --> 04:14.240
The first example is going to be very similar to maps.

04:14.240 --> 04:18.660
So let's say you have connection one to four and you have a function called F, which simply returns

04:18.680 --> 04:19.100
a square.

04:19.460 --> 04:22.370
So it's exactly the same thing that we've done before.

04:22.940 --> 04:29.990
So broadcast F on collection essentially means take F and apply it on each individual element of the

04:29.990 --> 04:30.530
collection.

04:30.800 --> 04:33.560
So this is going to do the same thing as MAP, right?

04:33.680 --> 04:36.530
So one four six except there is a minor difference.

04:37.140 --> 04:39.760
First, the collection does not change, obviously.

04:39.800 --> 04:42.800
So this creates a new collection for us.

04:43.040 --> 04:43.820
Just keep that in mind.

04:44.240 --> 04:49.550
Broadcasts are so useful that they have a dedicated syntax for them in Julia, and that is you take

04:49.550 --> 04:55.520
the function that you want to broadcast or send to each element you appended to it and then give it

04:55.520 --> 04:58.380
the collection on which this function should be applied.

04:58.520 --> 05:00.230
So after collection is the same as.

05:00.310 --> 05:06.580
Broadcast Election Day, you will notice that you cannot do election because if you try to do that,

05:06.590 --> 05:12.490
collection is going to go into X and the body is going to try and square the array and the array cannot

05:12.490 --> 05:12.940
be squared.

05:13.210 --> 05:15.600
So if you try to do a collection, it's going to give you an error.

05:15.910 --> 05:20.580
No method matching squared for an array, so you cannot square it.

05:20.860 --> 05:23.110
So you see the difference between these two.

05:23.320 --> 05:29.140
When people come to Julia, they really have trouble understanding this concept of f dot or the dot

05:29.140 --> 05:29.540
operator.

05:29.740 --> 05:31.330
OK, so that is all there is to it.

05:31.450 --> 05:33.430
It's a shortcut for the broadcast function.

05:33.610 --> 05:35.940
OK, let's go ahead and take a look at some examples.

05:36.100 --> 05:42.160
So if you say M is equal to one of three comma three, now you have a matrix and you can simply go ahead

05:42.160 --> 05:42.550
and.

05:43.610 --> 05:47.000
Try to do FFM now, matrices can be squared.

05:47.300 --> 05:48.550
You know how to square a matrix.

05:48.830 --> 05:51.980
You do the arithmetic and the algebra and it gives you a result.

05:52.460 --> 06:00.590
So FFM is one into one plus one and one plus one and one that goes in the first row, first column and

06:00.590 --> 06:00.860
so on.

06:00.880 --> 06:03.580
It you can write two copies of The Matrix SIDE-BY-SIDE and do the squaring.

06:03.590 --> 06:04.730
It's fairly straightforward.

06:05.540 --> 06:14.120
But if DOT is different, what this does is it applies the squared function on each element individually.

06:14.130 --> 06:18.110
So the f dot m result is one one, one on one and EFM.

06:18.110 --> 06:21.440
Is this so completely different things to different operations?

06:21.510 --> 06:23.930
OK, let's take a couple of more examples.

06:23.940 --> 06:25.400
So one, two, three, four, five, six.

06:25.430 --> 06:28.370
This is our three by three array or matrix.

06:29.150 --> 06:31.650
We can go ahead and say eight dot plus one.

06:32.390 --> 06:36.830
What this is saying is apply the plus operator on all elements of this.

06:36.830 --> 06:39.140
And because plus takes two arguments.

06:39.470 --> 06:45.330
One argument is going to come from the array and the second is this one guy over here so we can say

06:45.340 --> 06:46.400
eight plus one.

06:46.550 --> 06:48.920
And this is going to add one to each element.

06:49.310 --> 06:51.990
So extremely easy to work with.

06:52.010 --> 06:56.320
Plus, you will notice that this is very similar to what people in mathematics write this as.

06:56.330 --> 06:59.210
So people typically add matrices with scalars.

06:59.210 --> 07:04.460
And the idea is that you are going to add that scale to each element individually, just as you have

07:04.730 --> 07:06.140
a dot star too.

07:06.140 --> 07:09.470
And that is going to multiply each element of a with two.

07:09.680 --> 07:09.960
Right.

07:10.220 --> 07:15.380
And this is so common in mathematics that people typically write this as to a and Julia supports that

07:15.800 --> 07:17.140
and you can do to it.

07:17.480 --> 07:24.470
So when you see today what this means is we are taking the multiplying operator or the multiplication

07:24.470 --> 07:28.820
operator and we are broadcasting it to the whole matrix.

07:29.160 --> 07:29.430
Right.

07:29.690 --> 07:33.350
And what's the second argument for multiply are going to be that is this guy over here.

07:33.560 --> 07:40.160
So a very, very concise syntax that is very close to the syntax of mathematics that people are familiar

07:40.160 --> 07:40.340
with.

07:40.970 --> 07:45.800
Now, you can take these concepts and bring them together and you can write F dot to a.

07:45.830 --> 07:53.030
So what that means is first applied into two operator to each element individually and then apply or

07:53.030 --> 07:56.390
broadcast F on all the different elements as well.

07:56.810 --> 08:03.770
So instead of having to write map F, comma a comma map F and such and stuff like really messy stuff,

08:03.980 --> 08:09.410
you can just write f got to a which seems very, very close to the way mathematics is written.

08:09.710 --> 08:11.960
So this comes up again and again in Giulia's practice.

08:12.230 --> 08:17.830
We try to make the syntax of Julia or our code as close to the mathematics index as possible.

08:18.020 --> 08:23.630
That is why we have variable names as Unicode so you can have it in between Zyda and all of that in

08:23.630 --> 08:24.200
your code.

08:24.470 --> 08:24.720
Right.

08:24.760 --> 08:27.230
So that is all there is to it, but it's very powerful.

08:27.350 --> 08:30.830
OK, so let's go ahead and take a look at one final example.

08:30.830 --> 08:37.330
So let's say we have this at a A so this is a two by three array or a matrix to through Matrix.

08:37.730 --> 08:44.780
So if you try to multiply this with another vector, you will see that this is going to try and multiply

08:44.780 --> 08:49.430
it two by three matrix with a one by three vector.

08:49.730 --> 08:50.930
That obviously does not work.

08:51.090 --> 08:55.340
You need a three by one so you can do the transpose of this, but that is a different operator.

08:56.060 --> 08:59.390
What we want to do is we want to multiply this guy.

09:00.290 --> 09:06.600
If you do not start, this is going to take this guy over here and multiply it with this and then multiply

09:06.600 --> 09:07.060
it with this.

09:07.100 --> 09:08.320
OK, so let's do that.

09:08.660 --> 09:14.510
So you will see one gets multiplied by ten to twenty and three with thirty, and then this vector is

09:14.510 --> 09:20.600
repeatedly placed in this location and then forward is multiplied by then five at twenty and six with

09:20.600 --> 09:20.920
thirty.

09:21.080 --> 09:21.390
Right.

09:21.430 --> 09:22.750
So that is what we get over here.

09:23.090 --> 09:27.770
So you can keep doing this, you can say five, eight, seven.

09:28.070 --> 09:29.930
And this is going to give you.

09:30.610 --> 09:32.000
So let's get rid of that.

09:34.660 --> 09:39.170
You can do that and this is going to give you 50 116 do then.

09:39.520 --> 09:46.150
The idea is that broadcasting you can think of this as repeating something so you can repeat a function,

09:46.360 --> 09:50.800
you can repeat a scalar, or you can even repeat vectors over here.

09:51.100 --> 09:51.330
Right.

09:51.730 --> 09:52.960
So let's get rid of that.

09:53.740 --> 10:00.850
We can also go ahead and change the shape of this from a row vector to a kilometer using the transpose.

10:01.120 --> 10:05.820
And now what this is going to do is it's going to multiply 10 with one, 20 with four.

10:06.160 --> 10:12.540
Then the repeated multiplication is going to be 10 to 20 with five and then one more time, 10 with

10:12.550 --> 10:13.910
three and six with 20.

10:14.230 --> 10:15.190
So you get that out.

10:15.430 --> 10:18.400
OK, so let's say variable.

10:18.790 --> 10:22.580
So then 80, 20 hundred and thirty 120.

10:22.980 --> 10:24.430
OK, so I hope that made sense.

10:24.790 --> 10:29.260
You can think of broadcasting as repetition and that's all there is to it.

10:30.310 --> 10:35.470
If you understand this one thing, if dot to a what that means, you're going to go.

10:35.590 --> 10:38.890
OK, so please make sure that you understand the concept of broadcasting.

10:38.890 --> 10:42.520
This is going to come up again and again when we go into data science and machine learning.

10:42.670 --> 10:48.880
And this is like the foundation of Julia, because this is what makes Julia Syntex different from another

10:48.880 --> 10:50.860
language that you might have worked with, such as Python.

10:51.160 --> 10:56.710
So people have trouble with this, but once you do get used to it, you're going to appreciate how concise

10:56.710 --> 11:04.270
this makes your code and how easy it is to go from a research paper or a mathematician's work to a fully

11:04.270 --> 11:05.530
fledged working program.
