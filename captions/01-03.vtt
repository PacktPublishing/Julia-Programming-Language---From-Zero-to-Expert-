WEBVTT

00:01.180 --> 00:04.990
Let's do something a little more interesting, so in this video, we are going to take a look at the

00:04.990 --> 00:06.960
data structures that are built into Julia.

00:07.210 --> 00:11.890
Again, I'm going to do some parallels with Python so that you find it easier to understand.

00:11.890 --> 00:14.940
But even if you haven't worked with Python before, that's perfectly fine.

00:14.950 --> 00:16.480
This should make sense regardless.

00:16.890 --> 00:18.460
So let's go ahead and clear this first.

00:19.060 --> 00:21.340
So let's first create a basic collection.

00:21.640 --> 00:25.120
So this is going to be a list or what Julia calls an array.

00:25.330 --> 00:27.510
OK, so we have this collection over here.

00:27.610 --> 00:34.360
You can see that this is a four element array and the type of each element within that array is 64 bit

00:34.360 --> 00:34.800
integer.

00:34.930 --> 00:36.850
So it's an array of insectivores.

00:37.060 --> 00:40.570
You will notice that Julia has strict typing for its arrays.

00:40.900 --> 00:45.850
You can always have different types within the array, but the type of the array itself is going to

00:45.850 --> 00:49.680
be defined according to certain rules, which will take a look at right now.

00:49.990 --> 00:55.930
So if you define the same list and change five to five point, or it's going to convert this into a

00:55.930 --> 00:56.860
flawed 64.

00:57.220 --> 01:04.160
So now all of the elements within the list that you provided are converted or promoted to floor 64.

01:04.630 --> 01:10.270
The reason for that is if you have lists or arrays which hold elements of the same type, it speeds

01:10.270 --> 01:11.500
up the performance by a lot.

01:11.800 --> 01:18.010
So Julia, by default, converts everything into Florida 64 if you have just 164 in your collection

01:18.220 --> 01:19.660
or your array or list.

01:19.840 --> 01:25.840
OK, so even though we had integers over here, they have been converted into floats and float 64 is

01:25.840 --> 01:26.330
the default.

01:26.530 --> 01:30.340
This is going to create some problems when we get into machine learning, but we'll cover this when

01:30.340 --> 01:30.820
we get there.

01:30.880 --> 01:33.590
OK, just keep this in mind for what, 64 is the default.

01:33.880 --> 01:37.390
You can also have completely different types so you can have fractions.

01:37.690 --> 01:40.570
So you will see that because everything is being promoted to offload.

01:40.750 --> 01:45.320
This fraction is also promoted to a float and returns to one point six six six seven.

01:45.370 --> 01:52.870
OK, what if you try to use something that cannot be converted into a different type so you have integers

01:52.870 --> 01:56.180
and a string, neither of them can be promoted to the other.

01:56.530 --> 02:02.890
So what happens is Julia creates a list and the type of all the elements is now any so any like at the

02:02.890 --> 02:04.890
top of the hierarchy of Juliar types.

02:05.200 --> 02:10.480
So you have any and then you have numbers and you have strings and characters or any essentially means

02:10.480 --> 02:11.530
you can have any type.

02:11.890 --> 02:16.720
This is going to be a problem if you use it in actual computation, because this is going to really

02:16.720 --> 02:19.050
slow down your code if you use any.

02:19.060 --> 02:24.850
So it's much better to actually define what kind of data you're going to hold in a list and then work

02:24.850 --> 02:25.960
with that specific data.

02:26.220 --> 02:29.710
Genius data in a list aren't really all that useful anyway.

02:29.950 --> 02:30.250
OK.

02:31.170 --> 02:35.750
So let's go ahead and do some operations on these lists, so will define our list as one, two, four,

02:35.760 --> 02:36.050
five.

02:36.060 --> 02:39.240
So it's 1764 array four elements.

02:39.240 --> 02:45.110
Obviously we can append something to this collection by using the Append Beldin function.

02:45.360 --> 02:47.260
You will notice that it ends with a bang.

02:47.490 --> 02:54.540
So this exclamation mark at the end essentially is Julias convention of defining functions which modify

02:54.540 --> 02:55.230
its arguments.

02:55.230 --> 02:57.780
So you are passing it the collection, which is a list or an array.

02:58.170 --> 03:00.000
I'm going to use both of these interchangeably.

03:00.180 --> 03:05.370
You are passing it this array and this is going to be modified by the append functions or by convention.

03:05.760 --> 03:08.580
This append function has exclamation mark at the end.

03:08.820 --> 03:14.090
OK, there is nothing special about the exclamation mark from a syntax perspective.

03:14.100 --> 03:15.110
It's just a convention.

03:15.570 --> 03:18.540
So we are going to append 60 to this collection once we do that.

03:18.840 --> 03:22.000
You can see that collection now has the 60 at the end.

03:23.430 --> 03:26.730
Let's reset this and try to access the first element.

03:26.760 --> 03:32.810
So if you come from Python or C or Java, you probably would be doing collection WSDL.

03:33.120 --> 03:37.440
And this is extremely important that Julia does not have zero based indices.

03:37.800 --> 03:40.080
So Collections zero is invalid.

03:40.080 --> 03:42.710
And Julia Julia uses one based index.

03:42.900 --> 03:45.570
So the first element is in the index number one.

03:45.690 --> 03:45.970
Right.

03:46.260 --> 03:47.380
There are reasons for this.

03:47.670 --> 03:48.990
Don't get upset about this.

03:49.210 --> 03:50.670
It's just how Julia does things.

03:50.790 --> 03:53.620
If you used Matlab, that uses the same syntax.

03:53.640 --> 03:55.720
OK, so there are reasons for doing this.

03:55.860 --> 03:56.850
Let's not go into that.

03:57.480 --> 03:58.410
So we have this.

03:58.650 --> 04:02.040
You can always do slicing so you can go from one to five.

04:02.100 --> 04:03.510
This again is different from Python.

04:03.810 --> 04:08.850
One, two, five means start from the first element, go all the way up to the fifth element and both

04:08.850 --> 04:09.980
of them are included.

04:10.470 --> 04:14.280
So collection one two five is 10, 20, 30, 40 and 50.

04:14.430 --> 04:17.150
OK, many languages stopped just before this.

04:17.160 --> 04:19.740
So you have to make sure that you get comfortable with this.

04:19.740 --> 04:21.020
When you're using Julia.

04:21.360 --> 04:26.630
You can also start from a location and go all the way up to the end using the keyword.

04:26.650 --> 04:29.730
So if you say five to end, it starts from the fifth element.

04:30.270 --> 04:34.770
And because this is one based index, we actually start from the fifth element and we go all the way

04:34.770 --> 04:35.400
up to the end.

04:35.680 --> 04:37.980
OK, you can omit both of these.

04:38.250 --> 04:39.660
So you have this.

04:39.660 --> 04:43.890
And essentially this whole thing creates a copy of the array that you have.

04:44.190 --> 04:49.890
If you do collection colon for if you're coming from Python, you might be thinking that this is going

04:49.890 --> 04:53.790
to start from the start and it's going to go up to the fourth element.

04:54.090 --> 04:56.670
But that is not the case over here, if you recall.

04:59.040 --> 05:06.120
In BASIX, we saw that you have what are called symbols, so we over here calling for essentially is

05:06.120 --> 05:07.430
just an integer four.

05:07.890 --> 05:11.860
So if you put colon four over here, this means just four.

05:12.270 --> 05:16.930
So if you do collection, calling for this gives you the single element at index four.

05:17.340 --> 05:21.510
So this is kind of confusing for people coming to Julia from another language.

05:21.730 --> 05:27.150
So if you want to get all the elements from the start all the way up to the fourth element, you have

05:27.150 --> 05:28.170
to do one goal in four.

05:28.740 --> 05:32.170
So just getting to this index, make sure that you understand it, OK?

05:32.670 --> 05:35.670
Also, you cannot have negative indices.

05:35.850 --> 05:38.570
If you want to do that, you can do and minus one.

05:38.820 --> 05:40.590
And that will give you the same thing.

05:41.100 --> 05:42.120
It depends on who you ask.

05:42.150 --> 05:43.430
Some people say this is better.

05:43.440 --> 05:45.510
And obviously by then people say that this is better.

05:46.500 --> 05:47.790
You get used to it really quickly.

05:48.060 --> 05:49.290
It's not all that troublesome.

05:49.920 --> 05:53.640
You can obviously go ahead and change the individual elements.

05:53.640 --> 05:57.690
So you can say collection one is equal to ninety nine and that is going to change the stuff.

05:58.680 --> 06:02.970
If you want to look at the values of different things, you can use the macro.

06:03.000 --> 06:04.080
So this is called a macro.

06:05.220 --> 06:10.080
If you do actual collection, it's going to say collection is equal to this whole thing and then it's

06:10.080 --> 06:11.760
going to output the actual value as well.

06:13.140 --> 06:17.910
Typically when you're trying to debug stuff, you say show collection and then you add a semicolon at

06:17.910 --> 06:18.260
the end.

06:18.630 --> 06:24.960
What that means is it's going to do the actual showing so you'll get this line out, but it is not going

06:24.960 --> 06:27.440
to return the value of the collection itself.

06:27.690 --> 06:29.520
So you will not get this output.

06:29.850 --> 06:33.690
OK, so if you say show collection, semicolon, you get just that value.

06:34.170 --> 06:38.820
This is going to make more sense when you output multiple values, which will do in a little while.

06:39.000 --> 06:41.370
OK, let's create a copy of the collection.

06:41.370 --> 06:43.340
Using copy of collection is equal to collection.

06:43.350 --> 06:45.790
If you do that, you get a copy of collection.

06:45.820 --> 06:46.560
So this is a copy.

06:46.830 --> 06:50.510
If you change the first value of copy of collection to one hundred.

06:51.210 --> 06:52.830
So this ninety nine is going to change.

06:52.830 --> 06:53.290
Two hundred.

06:54.150 --> 07:01.200
OK, but the problem is that if you try to look at collection now, the value of the first element of

07:01.200 --> 07:02.520
collection has also changed.

07:02.550 --> 07:07.120
The reason for that is this does not create a copy.

07:07.500 --> 07:10.840
It just creates a new variable that is pointing to the same list.

07:10.980 --> 07:16.200
So in the realm you have this list sitting somewhere, collection is pointing to it and copies of collection

07:16.200 --> 07:17.910
is also pointing to the same list.

07:18.150 --> 07:22.320
So if you change this ninety nine, both collection and copy of collection are going to change.

07:22.620 --> 07:27.570
What we actually want to do is we want to create a copy of this whole list.

07:27.870 --> 07:32.020
And in order to do that, you have to use the built in function called copy.

07:32.430 --> 07:35.900
So let's create a second copy and we're going to use the copy function now.

07:36.300 --> 07:41.970
And if you do that and change the first element of second copy, two nine nine nine nine and output

07:41.970 --> 07:47.130
all of these three using the macro, you will see that second copy has changed.

07:47.730 --> 07:49.490
Collection remains the same.

07:49.500 --> 07:55.080
And so this copy of collection because second copy is now completely decoupled from our original collection

07:55.710 --> 07:56.490
of that made sense.

07:56.870 --> 08:02.060
There is also an issue of deep copy, but we leave that for more advanced videos when we get to those.

08:02.070 --> 08:04.260
And when we need that, we'll see what deep copies.

08:04.560 --> 08:09.690
So those are the basic operations that you can do with arrays or lists or data that is very similar

08:09.690 --> 08:13.230
to lists on race, but which is immutable is called tuples.

08:13.440 --> 08:16.710
So you can create tuples using parentheses around brackets.

08:16.720 --> 08:21.260
So you say collection is equal to one to four and you can have any data type in that.

08:21.270 --> 08:27.930
So you can have Julia by then see each other and you do one based indexing just as before, and you

08:27.930 --> 08:29.550
can try and modify it.

08:29.550 --> 08:32.030
But because it's immutable, it's going to give you an error.

08:32.040 --> 08:36.810
So it's a method error, no method matching set index, so on and so forth.

08:37.050 --> 08:42.960
What this means is you cannot set index, which means you cannot modify the value at this index, and

08:42.960 --> 08:44.880
that is because tables are immutable.

08:47.130 --> 08:48.890
If you look at languages, it remains the same.

08:49.380 --> 08:54.310
You can also have name tuples, which is kind of like a merger between arrays and dictionaries.

08:55.200 --> 08:58.380
The latest versions of Python are also adding support for this.

08:58.710 --> 09:02.100
But if you haven't seen this before, it has a very simple syntax.

09:02.100 --> 09:06.750
You can say Attwood's is equal to language, is equal to Julia Idiz, equal to Pluto and expiries.

09:06.750 --> 09:07.680
You can do perseverence.

09:08.040 --> 09:13.740
So if you do that, you can access elements of this tuple using numeric indices.

09:13.740 --> 09:15.290
Solitudes one is Julia.

09:15.300 --> 09:16.290
That is the first element.

09:16.530 --> 09:21.960
And you can also do tools, dot language so you can use the dot operator to access particular values.

09:22.410 --> 09:26.910
So this is kind of like a merger between lists and dictionaries and enumerations.

09:27.120 --> 09:29.370
So they're not very often used.

09:29.370 --> 09:32.020
But when they are, you should be aware of the syntax.

09:32.070 --> 09:33.960
OK, so the syntax is fairly straightforward.

09:34.170 --> 09:41.230
You have parenthesis instead of square records and you can do named elements.

09:41.370 --> 09:43.590
So language is equal to Julia and so on and so forth.

09:43.750 --> 09:46.700
OK, so those were the two basic data structures.

09:46.830 --> 09:49.650
The third one is dictionaries that will take a look at in the next video.
