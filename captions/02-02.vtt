WEBVTT

00:00.880 --> 00:03.910
So this is a very short video, even though we don't really need it.

00:03.940 --> 00:08.500
I hope you do go through this because there is one very small concept here that might be useful for

00:08.500 --> 00:09.020
you later on.

00:09.280 --> 00:11.020
So we've seen the basic data types.

00:11.020 --> 00:16.890
So we have in 64, we have floods, we have flood 64 us right.

00:17.350 --> 00:18.790
Type of ice fraud 64.

00:18.790 --> 00:24.670
You can convert this into a 32 bit flood, which is not going to be for 32, which is represented using

00:24.670 --> 00:25.270
EF zero.

00:25.500 --> 00:32.620
OK, we can also have complex numbers so we can have a complex number equal to one plus three into erm

00:32.620 --> 00:36.370
so this erm is a building which defines the imaginary part of a complex number.

00:37.120 --> 00:39.520
If you're not familiar with complex numbers, don't worry about this.

00:39.610 --> 00:43.600
This is just here for the sake of completeness, we don't really need them in machine learning aspect.

00:43.600 --> 00:48.280
If you're going to like physics simulation and all that, you might need it, but then you would already

00:48.280 --> 00:49.240
know what a complex number is.

00:49.270 --> 00:54.140
OK, so type of C is a complex number in which each element is in 64 type.

00:54.160 --> 00:59.470
You can also have floors here in which each part of the imaginary number itself is a float.

00:59.470 --> 01:03.650
And the way to create that is, you say, is equal to complex float 64.

01:03.670 --> 01:09.730
So this defines the type and you're essentially calling a constructor of this type and giving it the

01:09.730 --> 01:14.860
actual values, one plus three am, and that is going to create one to zero plus three point zero imaginary.

01:15.340 --> 01:19.440
Both the real and imaginary part are now floats instead of integers.

01:19.500 --> 01:23.800
OK, so this is a complex with the different parts as four sixty four.

01:24.010 --> 01:24.270
Right.

01:24.670 --> 01:27.070
You can have is equal to one, two four.

01:27.250 --> 01:29.020
So these are going to be insectivores.

01:29.080 --> 01:35.050
But if you are sure that you want them to be float's instead of integers, you can say floor 64 and

01:35.050 --> 01:39.640
square brackets and this is going to create a floor six for the same values.

01:39.650 --> 01:41.380
But now this is going to be a floor 64.

01:42.100 --> 01:45.910
So this is a shortcut for something very similar to above over here.

01:46.950 --> 01:55.560
The full version would be a sequel to Complex Flawed 64 one two five, so this creates an array of one,

01:55.560 --> 02:02.580
two, five, and each element is going to be a complex number in which both the real and the imaginary

02:02.580 --> 02:04.020
part are Fraunces to force.

02:04.240 --> 02:08.660
OK, so if you do that, you will see one point zero zero point zero imaginary.

02:09.090 --> 02:12.510
So this is an array in which each element is a complex.

02:12.570 --> 02:17.400
So even though we provided only real part, it's going to create the imaginary Barcott itself, both

02:17.400 --> 02:20.910
real and imaginary part are flaws because of this flawed 64 over here.

02:21.230 --> 02:22.290
OK, so that makes sense.

02:22.380 --> 02:25.920
If not, please do ask for answers and I'll try to clarify further.

02:26.150 --> 02:32.820
OK, we can also check whether an element is or is not a simple data type so we can say is a one insectivores.

02:32.850 --> 02:33.750
Obviously it's not.

02:33.750 --> 02:34.290
It's a flawed.

02:34.680 --> 02:37.380
If you ask is it a flawed 64, it will say true.

02:37.680 --> 02:39.370
If you ask is it a flawed 32?

02:39.450 --> 02:44.640
It says false because by default, all floats on my machine go to four 64.

02:44.780 --> 02:46.410
OK, so all this made sense.

02:46.410 --> 02:51.870
In the next video, we are going to start putting these things together into functions that can solve

02:51.930 --> 02:53.310
specific problems for us.
